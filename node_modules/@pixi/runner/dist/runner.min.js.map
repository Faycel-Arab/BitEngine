{"version":3,"file":"runner.min.js","sources":["../src/Runner.js"],"sourcesContent":["/**\n * A Runner is a highly performant and simple alternative to signals. Best used in situations\n * where events are dispatched to many objects at high frequency (say every frame!)\n *\n *\n * like a signal..\n * ```\n * const myObject = {\n *     loaded: new PIXI.Runner('loaded')\n * }\n *\n * const listener = {\n *     loaded: function(){\n *         // thin\n *     }\n * }\n *\n * myObject.update.add(listener);\n *\n * myObject.loaded.emit();\n * ```\n *\n * Or for handling calling the same function on many items\n * ```\n * const myGame = {\n *     update: new PIXI.Runner('update')\n * }\n *\n * const gameObject = {\n *     update: function(time){\n *         // update my gamey state\n *     }\n * }\n *\n * myGame.update.add(gameObject1);\n *\n * myGame.update.emit(time);\n * ```\n * @class\n * @memberof PIXI\n */\nexport default class Runner\n{\n    /**\n     *  @param {string} name the function name that will be executed on the listeners added to this Runner.\n     */\n    constructor(name)\n    {\n        this.items = [];\n        this._name = name;\n    }\n\n    /**\n     * Dispatch/Broadcast Runner to all listeners added to the queue.\n     * @param {...any} params - optional parameters to pass to each listener\n     */\n    emit(a0, a1, a2, a3, a4, a5, a6, a7)\n    {\n        if (arguments.length > 8)\n        {\n            throw new Error('max arguments reached');\n        }\n\n        const { name, items } = this;\n\n        for (let i = 0, len = items.length; i < len; i++)\n        {\n            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a listener to the Runner\n     *\n     * Runners do not need to have scope or functions passed to them.\n     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n     * as the name provided to the Runner when it was created.\n     *\n     * Eg A listener passed to this Runner will require a 'complete' function.\n     *\n     * ```\n     * const complete = new PIXI.Runner('complete');\n     * ```\n     *\n     * The scope used will be the object itself.\n     *\n     * @param {any} item - The object that will be listening.\n     */\n    add(item)\n    {\n        if (item[this._name])\n        {\n            this.remove(item);\n            this.items.push(item);\n        }\n\n        return this;\n    }\n\n    /**\n     * Remove a single listener from the dispatch queue.\n     * @param {any} item - The listenr that you would like to remove.\n     */\n    remove(item)\n    {\n        const index = this.items.indexOf(item);\n\n        if (index !== -1)\n        {\n            this.items.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    /**\n     * Check to see if the listener is already in the Runner\n     * @param {any} item - The listener that you would like to check.\n     */\n    contains(item)\n    {\n        return this.items.indexOf(item) !== -1;\n    }\n\n    /**\n     * Remove all listeners from the Runner\n     */\n    removeAll()\n    {\n        this.items.length = 0;\n\n        return this;\n    }\n\n    /**\n     * Remove all references, don't use after this.\n     */\n    destroy()\n    {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n\n    /**\n     * `true` if there are no this Runner contains no listeners\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    get empty()\n    {\n        return this.items.length === 0;\n    }\n\n    /**\n     * The name of the runner.\n     *\n     * @member {string}\n     * @readonly\n     */\n    get name()\n    {\n        return this._name;\n    }\n}\n\n/**\n * Alias for `emit`\n * @memberof PIXI.Runner#\n * @method dispatch\n * @see PIXI.Runner#emit\n */\nRunner.prototype.dispatch = Runner.prototype.emit;\n\n/**\n * Alias for `emit`\n * @memberof PIXI.Runner#\n * @method run\n * @see PIXI.Runner#emit\n */\nRunner.prototype.run = Runner.prototype.emit;\n"],"names":["Runner","name","this","items","_name","emit","a0","a1","a2","a3","a4","a5","a6","a7","arguments","length","Error","i","len","add","item","remove","push","const","index","indexOf","splice","contains","removeAll","destroy","prototypeAccessors","empty","prototype","dispatch","run"],"mappings":";;;;;;;kEAyCe,IAAMA,EAKjB,SAAYC,GAERC,KAAKC,MAAQ,GACbD,KAAKE,MAAQH,6DAOrBD,YAAIK,cAAKC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,GAE7B,GAAIC,UAAUC,OAAS,EAEnB,MAAM,IAAIC,MAAM,yBAKpB,IAFJ,MAA4Bd,YAAAA,WAEfe,EAAI,EAAGC,EAAMf,EAAMY,OAAQE,EAAIC,EAAKD,IAE7Cd,EAAUc,GAAGhB,GAAMK,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,GAGnD,OAAWX,MAoBfF,YAAImB,aAAIC,GAQJ,OANQA,EAAKlB,KAAKE,SAEVF,KAAKmB,OAAOD,GAChBlB,KAASC,MAAMmB,KAAKF,IAGblB,MAOfF,YAAIqB,gBAAOD,GAEHG,IAAMC,EAAQtB,KAAKC,MAAMsB,QAAQL,GAOrC,OALmB,IAAXI,GAEJtB,KAASC,MAAMuB,OAAOF,EAAO,GAGtBtB,MAOfF,YAAI2B,kBAASP,GAEL,OAAqC,IAA9BlB,KAAKC,MAAMsB,QAAQL,IAMlCpB,YAAI4B,qBAIA,OAFI1B,KAAKC,MAAMY,OAAS,EAEbb,MAMfF,YAAI6B,mBAEI3B,KAAK0B,YACL1B,KAAKC,MAAQ,KACbD,KAAKE,MAAQ,MASrB0B,EAAQC,qBAEJ,OAAiC,IAAtB7B,KAAKC,MAAMY,QAS1Be,EAAQ7B,oBAEA,OAAOC,KAAKE,8CAUpBJ,EAAOgC,UAAUC,SAAWjC,EAAOgC,UAAU3B,KAQ7CL,EAAOgC,UAAUE,IAAMlC,EAAOgC,UAAU3B"}